// @bun
class H{root={name:"/",children:[]};isOptimized=!1;addRoute(D,W,G){const X=W.split("/").filter(Boolean);let Z=this.root;for(let $=0;$<X.length;$++){const Y=X[$],J=Y[0]===":",U=Y[0]==="*";let M=Z.children.find((F)=>F.name===($===0?"":"/")+Y&&(F.method===D||!F.method));if(M&&M.method===D&&$===X.length-1)throw new Error(`Route ${D} ${W} already exists`);if(!M)M={name:($===0?"":"/")+Y,children:[],isParameterNode:J,isWildcardNode:U},Z.children.push(M);Z=M}Z.handler=G,Z.method=D}_addHookToNode(D,W,G){switch(W){case"beforeHandler":{if(!D.beforeHandlerHook)D.beforeHandlerHook=[];D.beforeHandlerHook.push(G);break}case"afterHandler":{if(!D.afterHandlerHook)D.afterHandlerHook=[];D.afterHandlerHook.push(G);break}case"beforeAndAfterHandler":{if(!D.beforeHandlerHook)D.beforeHandlerHook=[];if(!D.afterHandlerHook)D.afterHandlerHook=[];D.beforeHandlerHook.push(G),D.afterHandlerHook.push(G);break}default:break}}addHook(D,W,G,X,Z){if(this.isOptimized)throw new Error("Cannot add hooks after the tree has been optimized");const $=W.split("/").filter(Boolean);let Y=Z||this.root;for(let J=0;J<$.length;J++){const U=$[J];if(U[0]==="*"){const Q="/"+$.slice(J+1).join("/");for(let _ of Y.children)if(_.method===X||!_.method)this.addHook(D,Q,G,X,_);return}const F=Y.children.find((Q)=>Q.name===(Y.name==="/"?"":"/")+U&&(Q.method&&Q.method===X||!Q.method));if(!F)break;Y=F}this._addHookToNode(Y,D,G)}findRoute(D,W){let G=W;if(W[0]!=="/")G="/"+W;const{length:X}=G;if(X===1&&G==="/")return this.root;let Z=0,$=void 0;const Y=(U,M,F)=>{const Q=M+(F-M);for(let _=0;_<U.children.length;_++){const V=U.children[_],j=V.name,L=V.isWildcardNode||V.isParameterNode;if(Z=G.indexOf("/",L?Q+1:Q+j.length-1),Z===-1)Z=X;if(F===Z&&!V.isWildcardNode)continue;if(!L&&Z-Q!==j.length)continue;if(V.isParameterNode){if(!$)$={};const O=M===0?0:1;$[j.slice(1+O)]=G.slice(Q+O,Z)}if(L&&V.children.length===0)return V;if(Z>=X-1&&(V.method===D||V.method==="ALL")){if(L)return V;if(G.slice(Q,Z)===j)return V}const A=Y(V,Q,Z);if(A)return A}return null},J=Y(this.root,0,this.root.name.length);if($&&J)J.params=$;return J}optimizeTree(){const D=(W)=>{if(W.children.length===1&&!W.handler&&!W.isParameterNode&&!W.children[0].isParameterNode&&!W.isWildcardNode&&!W.children[0].isWildcardNode&&W.name!=="/"){const G=W.children[0];W.name+=G.name,W.children=G.children,W.handler=G.handler,W.method=G.method,W.beforeHandlerHook=G.beforeHandlerHook,W.afterHandlerHook=G.afterHandlerHook,D(W)}W.children.forEach(D)};D(this.root),this.isOptimized=!0}}class z{request;response=void 0;headers=new Headers;status=200;statusText="OK";constructor(D){this.request=D}setCookie(D,W,G){let X=`${D}=${W};`;if(G){const{httpOnly:Z,path:$,domain:Y,expires:J,sameSite:U,maxAge:M,secure:F}=G;if(Z)X=`${X} HttpOnly;`;if($)X=`${X} Path=${$};`;if(Y)X=`${X} Domain=${Y};`;if(J)X=`${X} Expires=${J.toUTCString()};`;if(U)X=`${X} SameSite=${U};`;if(F)X=`${X} Secure;`;if(M)X=`${X} Max-Age=${M};`}this.headers?.append("Set-Cookie",X)}getCookie(D){const W=this.request.headers.get("Cookie");if(!W)return;const G=W.split(";").find((X)=>X.includes(D));if(!G)return;return G.split("=")[1]}deleteCookie(D){this.setCookie(D,"",{expires:new Date(0)})}sendJson(D){return this.headers.set("content-type","application/json"),this.headers.set("charset","utf-8"),this.response=new Response(JSON.stringify(D),{headers:this.headers,status:this.status,statusText:this.statusText}),this.response}sendText(D){return this.headers.set("content-type","text/plain"),this.headers.set("charset","utf-8"),this.response=new Response(D,{headers:this.headers,status:this.status,statusText:this.statusText}),this.response}send(D,{status:W,statusText:G,headers:X=new Headers}={}){let Z;if(typeof D==="object")this.headers.set("content-type","application/json"),Z=JSON.stringify(D);else this.headers.set("content-type","text/plain"),Z=D;if(this.headers.set("charset","utf-8"),W)this.status=W;if(G)this.statusText=G;if(X){const $=Object.entries(X);for(let[Y,J]of $)this.headers?.set(Y,J)}return this.response=new Response(Z,{headers:this.headers,status:this.status,statusText:this.statusText}),this.response}}var f=(D)=>{const W=D.indexOf("?",8),G=D.length,X=W!==-1,Z=D.slice(D.indexOf("/",8),!X?G:W);if(X){const $={};let Y=W+1,J=-1;for(let U=W+1;U<G;U++){const M=D[U];if(M==="="){J=U;continue}if(M==="&"||U===G-1)$[D.slice(Y,J)]=D.slice(J+1,U===G-1?U+1:U),Y=U+1}return{pathName:Z,searchParams:$}}return{pathName:Z}};class K{res;request;params={};pathname="";query={};state="beforeHandler";requestStartTimeInMs=void 0;getIpAdress=()=>"";handler=void 0;beforeHandlerHook=[];afterHandlerHook=[];constructor(D,W){this.request=D,this.res=new z(D),this._findRoute(W)}_findRoute(D){const{pathName:W,searchParams:G}=f(this.request.url),X=D?.findRoute(this.request.method,W);this.query=G||{},this.pathname=W,this.params=X?.params||{},this.handler=X?.handler,this.beforeHandlerHook=X?.beforeHandlerHook||[],this.afterHandlerHook=X?.afterHandlerHook||[]}redirect(D,W=302){this.res.headers.set("Location",D),this.res.status=W}async executeHandler(){this.state="beforeHandler";for(let G of this.beforeHandlerHook)await G(this);const D=await this.handler?.(this);if(D instanceof Response)this.res.response=D;this.state="afterHandler";let W=void 0;for(let G of this.afterHandlerHook)W=await G(this);if(W instanceof Response)return W;return this.res.response||new Response(null,{status:404})}}class R extends Error{response;constructor(D){super(D.statusText);this.response=D}}class C{options;store;intervalId=void 0;constructor(D){this.options=D,this.store={},this._init()}_init(){this.intervalId=setInterval(()=>{this.clear()},this.options.interval)}set(D,W){this.store[D]=W}get(D){return this.store[D]}clear(){this.store={}}stop(){clearInterval(this.intervalId)}}var v=(D)=>{return{perMessageDeflate:D?.compression,maxPayloadLength:D?.maxPayloadLength,idleTimeout:D?.idleTimeout,backpressureLimit:D?.backpressureLimit,closeOnBackpressureLimit:D?.closeOnBackpressureLimit,message(W,G){D?.onMessage?.(W,G)},open(W){D?.onOpen?.(W)},close(W,G,X){D?.onClose?.(W,G,X)},drain(W){D?.onDrain?.(W)}}};var B=new C({interval:1e4}),E=()=>({createServer:(D,W,G,X)=>Bun.serve({port:D,tls:{...G?.tls},hostname:G?.hostname,development:!0,websocket:v(X),async fetch(Z,$){try{const Y=Z.url+"$method:"+Z.method;let J=B.get(Y);if(J)J.request=Z,J.res=new z(Z);else J=new K(Z,W),B.set(Y,J);if(J.getIpAdress=()=>this.requestIP(Z)?.address||"",X&&X.path===J.pathname){for(let U of X.beforeWebSocketUpgrade||[])await U(J);if($.upgrade(Z))return}if(!J.handler)return G?.onNotFound?.(Z),new Response(null,{status:404});return await J.executeHandler()}catch(Y){if(Y instanceof Error)G?.onError?.(Y);if(Y instanceof R)return Y.response;return new Response(Y.message,{status:Number(Y.code)||500})}}}),stopServer:async(D)=>D.stop()});import{createServer as I} from"http";import{createServer as S} from"https";var w=async(D)=>{const W={};if(D.headers.forEach((G,X)=>{W[X]=G}),D.headers.get("content-type")==="appplication/json")return{headers:W,body:await D.json()};return{headers:W,body:await D.text()}},y=new C({interval:1e4}),b=()=>({createServer:(D,W,G)=>{const X=G?.tls?S:I,Z={...G?.tls};return X(Z,async($,Y)=>{const J=`http://${$.headers.host}${$.url}`;let U="";$.on("data",(M)=>{U+=M}),$.on("end",async()=>{try{const M=J+"$method:"+$.method;let F=y.get(M);const Q=new Request(J,{method:$.method,headers:$.headers,body:$.method!=="GET"&&$.method!=="HEAD"?U:void 0});if(!F)F=new K(Q,W),y.set(M,F);else F.request=Q,F.res=new z(Q);if(!F.handler){G?.onNotFound?.(F.request),Y.writeHead(404),Y.end();return}F.getIpAdress=()=>$.socket.remoteAddress||"";const _=await F.executeHandler(),{headers:V,body:j}=await w(_);Y.writeHead(_.status||404,_.statusText,V),Y.write(j)}catch(M){if(M instanceof Error)G?.onError?.(M);if(!(M instanceof R)){Y.writeHead(Number(M.code)||500),Y.write(M.message),Y.end();return}const{headers:F,body:Q}=await w(M.response);Y.writeHead(M.response.status||500,M.response.statusText,F),Y.write(Q)}Y.end()})}).listen(D)},stopServer:(D)=>D.close()});var P=()=>{if(typeof Bun!=="undefined"&&!process.env.NODE_TEST)return E();return b()};class T{options;server;hooks;router;runtimeAdapter=P();httpMethods=["GET","POST","PUT","DELETE"];webSocket=void 0;constructor(D){this.options=D,this.hooks=[],this.server=null,this.router=new H}get(D,W,G){if(G)this._addHook("beforeHandler","GET")(D,G);return this.router.addRoute("GET",D,W),this}post(D,W,G){if(G)this._addHook("beforeHandler","POST")(D,G);return this.router.addRoute("POST",D,W),this}put(D,W,G){if(G)this._addHook("beforeHandler","PUT")(D,G);return this.router.addRoute("PUT",D,W),this}delete(D,W,G){if(G)this._addHook("beforeHandler","DELETE")(D,G);return this.router.addRoute("DELETE",D,W),this}all(D,W,G){if(G)this.httpMethods.map((X)=>this._addHook("beforeHandler",X)(D,G));return this.router.addRoute("ALL",D,W),this}_addHook=(D,W)=>(G,...X)=>{let Z=G;if(typeof G!=="string")Z="*",X.unshift(G);return X.map(($)=>{if(typeof Z==="string")this.hooks.push({pathname:Z,handler:$,hook:D,method:W})}),this};beforeAndAfterHandler(D,...W){return this.httpMethods.map((G)=>this._addHook("beforeAndAfterHandler",G)(D,...W)),this}beforeHandler(D,...W){return this.httpMethods.map((G)=>this._addHook("beforeHandler",G)(D,...W)),this}afterHandler(D,...W){return this.httpMethods.map((G)=>this._addHook("afterHandler",G)(D,...W)),this}useWebSocket(D){return this.webSocket=D,this}usePlugin(D){if(D instanceof Promise)return D.then((W)=>{return W(this)}),this;return D(this),this}listen(D,W){for(let G of this.hooks)this.router.addHook(G.hook,G.pathname,G.handler,G.method);return this.router.optimizeTree(),this.server=this.runtimeAdapter.createServer(D,this.router,this.options,this.webSocket),W?.({port:D,hostname:this.options?.hostname||"localhost"}),this}stop(){this.runtimeAdapter.stopServer(this.server)}}export{f as extractPathnameAndSearchParams,v as bunWebSocket,C as WobeStore,z as WobeResponse,T as Wobe,H as RadixTree,b as NodeAdapter,R as HttpException,K as Context,E as BunAdapter};
